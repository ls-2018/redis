数据在删改操作时,如果不是删除缓存值,而是直接更新缓存的值,你觉得和删除缓存值相比,有什么好处和不足？

这种情况相当于把Redis当做读写缓存使用,删改操作同时操作数据库和缓存.

1、先更新数据库,再更新缓存：如果更新数据库成功,但缓存更新失败,此时数据库中是最新值,但缓存中是旧值,后续的读请求会直接命中缓存,得到的是旧值.

2、先更新缓存,再更新数据库：如果更新缓存成功,但数据库更新失败,此时缓存中是最新值,数据库中是旧值,后续读请求会直接命中缓存,但得到的是最新值,短期对业务影响不大.但是,一旦缓存过期或者满容后被淘汰,读请求就会从数据库中重新加载旧值到缓存中,之后的读请求会从缓存中得到旧值,对业务产生影响.

同样地,针对这种其中一个操作可能失败的情况,也可以使用重试机制解决,把第二步操作放入到消息队列中,消费者从消息队列取出消息,再更新缓存或数据库,成功后把消息从消息队列删除,否则进行重试,以此达到数据库和缓存的最终一致.

以上是没有并发请求的情况.如果存在并发读写,也会产生不一致,分为以下4种场景.

1、先更新数据库,再更新缓存,写+读并发：线程A先更新数据库,之后线程B读取数据,此时线程B会命中缓存,读取到旧值,之后线程A更新缓存成功,后续的读请求会命中缓存得到最新值.这种场景下,线程A未更新完缓存之前,在这期间的读请求会短暂读到旧值,对业务短暂影响.

2、先更新缓存,再更新数据库,写+读并发：线程A先更新缓存成功,之后线程B读取数据,此时线程B命中缓存,读取到最新值后返回,之后线程A更新数据库成功.这种场景下,虽然线程A还未更新完数据库,数据库会与缓存存在短暂不一致,但在这之前进来的读请求都能直接命中缓存,获取到最新值,所以对业务没影响.

3、先更新数据库,再更新缓存,写+写并发：线程A和线程B同时更新同一条数据,更新数据库的顺序是先A后B,但更新缓存时顺序是先B后A,这会导致数据库和缓存的不一致.

4、先更新缓存,再更新数据库,写+写并发：与场景3类似,线程A和线程B同时更新同一条数据,更新缓存的顺序是先A后B,但是更新数据库的顺序是先B后A,这也会导致数据库和缓存的不一致.

场景1和2对业务影响较小,场景3和4会造成数据库和缓存不一致,影响较大.也就是说,在读写缓存模式下,写+读并发对业务的影响较小,而写+写并发时,会造成数据库和缓存的不一致.

针对场景3和4的解决方案是,对于写请求,需要配合分布式锁使用.写请求进来时,针对同一个资源的修改操作,先加分布式锁,这样同一时间只允许一个线程去更新数据库和缓存,没有拿到锁的线程把操作放入到队列中,延时处理.用这种方式保证多个线程操作同一资源的顺序性,以此保证一致性.

综上,使用读写缓存同时操作数据库和缓存时,因为其中一个操作失败导致不一致的问题,同样可以通过消息队列重试来解决.而在并发的场景下,读+写并发对业务没有影响或者影响较小,而写+写并发时需要配合分布式锁的使用,才能保证缓存和数据库的一致性.

另外,读写缓存模式由于会同时更新数据库和缓存,优点是,缓存中一直会有数据,如果更新操作后会立即再次访问,可以直接命中缓存,能够降低读请求对于数据库的压力
（没有了只读缓存的删除缓存导致缓存缺失和再加载的过程）.缺点是,如果更新后的数据,之后很少再被访问到,会导致缓存中保留的不是最热的数据,缓存利用率不高（只读缓存中保留的都是热数据）,所以读写缓存比较适合用于读写相当的业务场景.




## 1
1.读操作时,先读缓存,缓存Miss,读DB.此时用SETNX写缓存,只有缓存中还没有时再会成功,操作缓存的优先级比较低;
2.写操作时,先删除缓存,再写DB成功,最后用SET写缓存;
3.订阅DB变更,用DB最终数据,SETEX操作刷新缓存.

针对以上
读读并发,没有问题
写写并发, 可能因为往Redis写数据的延迟,数据可能不一致     ,因为有3可以解决
读写并发, 没有问题